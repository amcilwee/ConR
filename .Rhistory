if(Rank_B1a==Rank_B2a) Cat_Code <- paste(Cat,"B1a+B2a")
if(!is.null(protec.areas)) {
if(as.numeric(Results["Ratio_occ_within_PA",1])==100){
Results["Category_CriteriaB",1] <- "NT or LC"
Results["Category_code",1] <- Cat_Code
}else{
Results["Category_CriteriaB",1] <- Cat
Results["Category_code",1] <- Cat_Code
}
}else{
Results["Category_CriteriaB",1] <- Cat
Results["Category_code",1] <- Cat_Code
}
if(Rank_B2a==1) Results["Category_AOO",1] <- "CR"
if(Rank_B2a==2) Results["Category_AOO",1] <- "EN"
if(Rank_B2a==3) Results["Category_AOO",1] <- "VU"
if(Rank_B2a>3) Results["Category_AOO",1] <- "NT or LC"
if(Rank_B1a==1) Results["Category_EOO",1] <- "CR"
if(Rank_B1a==2) Results["Category_EOO",1] <- "EN"
if(Rank_B1a==3) Results["Category_EOO",1] <- "VU"
if(Rank_B1a>3) Results["Category_EOO",1] <- "NT or LC"
}else{
p1 <- NULL
AOO <- nrow(unique(floor((unique(coordEAC))/(Cell_size_AOO*1000))))*Cell_size_AOO*Cell_size_AOO  ### AOO
Results["AOO",1] <- AOO
if(SubPop) Results["Nbe_subPop",1] <- NbeSubPop
Results["Nbe_unique_occ.",1] <- nrow(unique(XY))
if(!is.null(protec.areas)) Results["Ratio_occ_within_PA",1] <- round(length(which(!is.na(Links_NatParks[,1])))/nrow(Links_NatParks)*100,2)
if(is.null(protec.areas)) Results["Nbe_loc",1] <- Locations
if(!is.null(protec.areas)) Results["Nbe_loc",1] <- LocNatParks + LocOutNatParks
if(!is.null(protec.areas)) Results["Nbe_loc_PA",1] <- LocNatParks
if(!is.null(protec.areas)){
if(as.numeric(Results["Ratio_occ_within_PA",1])==100){ ### If all occurences are found within protected areas, the species is considered as not threatened
Results["Category_CriteriaB",1] <- "LC"
}else{
if(Results["Nbe_loc",1]==1 & Results["AOO",1]<10){
Results["Category_CriteriaB",1] <- "CR"
Results["Category_AOO",1] <- "CR"
}
if(Results["Nbe_loc",1]>1 & Results["AOO",1]<10) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}
}
}else{
if(Results["Nbe_loc",1]==1 & Results["AOO",1]<10){
Results["Category_CriteriaB",1] <- "CR"
Results["Category_AOO",1] <- "CR"
}
if(Results["Nbe_loc",1]>1 & Results["AOO",1]<10) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}
}
if(is.na(Results["Category_AOO",1])) {
if(Results["AOO",1] < 500) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}else{
if(Results["AOO",1] < 2000) {
Results["Category_CriteriaB",1] <- "VU"
Results["Category_AOO",1] <- "VU"
}else{
Results["Category_CriteriaB",1] <- "LC"
Results["Category_AOO",1] <- "LC"
}
}
}
Results["Category_code",1] <- paste(Results["Category_CriteriaB",1],"B2a")
if(showWarnings) warning(paste("EOO statistic is not computed for", NamesSp,"because there is less than 3 records"))
} ## End less than 3 records
nbe.rep.rast.AOO=NULL
if(nrow(unique(XY))>2) {
EOO_ <- EOO.computing(XY[,c(2,1)], exclude.area=exclude.area, country_map=poly_borders, Name_Sp=NamesSp,
buff_width=buff_width, export_shp=TRUE,
alpha=alpha, buff.alpha=buff.alpha, method.range=method.range, write.results=FALSE, verbose=FALSE)
p1 <- EOO_[[1]][[2]]
EOO <- EOO_[[1]][[1]]
###############
### AOO
###############
Corners <- rbind(c(min(XY[,1]), max(XY[,1])), c(min(XY[,2]), max(XY[,2])))
# border_to_center <- as.data.frame(matrix(NA, 2, 2))
# border_to_center[1,] <- c(mean(coordEAC[,1]), mean(coordEAC[,2]))
# border_to_center[2,] <- c( border_to_center[1,1]+Cell_size_AOO*1000,  border_to_center[1,2])
# DIST_circle <- matrix(unlist(rgdal::project(as.matrix(border_to_center),proj=as.character(projEAC),inv =T)), ncol=2)
# cell_size_deg <- abs((DIST_circle[1,1]-DIST_circle[2,1]))
#
# Occupied_cells <- c()
# decal <- c(0,1,2,3)
# for (h in decal) {
#   ext = extent(floor(Corners[1,1])-h*(cell_size_deg/4)-2, floor(Corners[1,2])+h*(cell_size_deg/4)+2,
#                floor(Corners[2,1])-h*(cell_size_deg/4)-2, floor(Corners[2,2])+h*(cell_size_deg/4)+2)
#   r = raster(ext, resolution=cell_size_deg,crs=crs(poly_borders))
#   r2_AOO <- rasterize(XY, r)
#   OCC <- length(which(!is.na(values(r2_AOO))))
#   Occupied_cells <- c(Occupied_cells, OCC)
#
#   ### If only one occupied cell, stop the production of raster
#   if(OCC==1) break
# }
# h <- decal[which.min(Occupied_cells)]
# Occupied_cells <- min(Occupied_cells)
Corners <- rbind(c(min(coordEAC[,1]), max(coordEAC[,1])), c(min(coordEAC[,2]), max(coordEAC[,2])))
if(is.null(nbe.rep.rast.AOO)) {
Occupied_cells <- c()
decal <- c(0,1,2,3)
for (h in decal) {
ext = extent(floor(Corners[1,1])-h*(Cell_size_AOO*1000/4)-2*Cell_size_AOO*1000, floor(Corners[1,2])+h*(Cell_size_AOO*1000/4)+2*Cell_size_AOO*1000,
floor(Corners[2,1])-h*(Cell_size_AOO*1000/4)-2*Cell_size_AOO*1000, floor(Corners[2,2])+h*(Cell_size_AOO*1000/4)+2*Cell_size_AOO*1000)
r = raster(ext, resolution=Cell_size_AOO*1000,crs=crs(poly_borders))
r2_AOO <- rasterize(coordEAC, r)
OCC <- length(which(!is.na(values(r2_AOO))))
Occupied_cells <- c(Occupied_cells, OCC)
### If only one occupied cell, stop the production of raster
if(OCC==1) break
}
h <- decal[which.min(Occupied_cells)]
Occupied_cells <- min(Occupied_cells)
}
# if(!is.null(nbe.rep.rast.AOO)) {
#   Occupied_cells <- c()
#   # rd.1.vec <- c()
#   # rd.2.vec <- c()
#   for (h in 1:nbe.rep.rast.AOO) {
#     rd.1 <- runif(1)*cell_size_deg
#     rd.2 <- runif(1)*cell_size_deg
#
#     ext = extent(floor(Corners[1,1])-rd.1-2, floor(Corners[1,2])+rd.1+2,
#                  floor(Corners[2,1])-rd.2-2, floor(Corners[2,2])+rd.2+2)
#     r = raster(ext, resolution=cell_size_deg,crs=crs(poly_borders))
#     r
#     r2_AOO <- rasterize(XY, r)
#     OCC <- length(which(!is.na(values(r2_AOO))))
#     Occupied_cells <- c(Occupied_cells, OCC)
#     # rd.1.vec <- c(rd.1.vec, rd.1)
#     # rd.2.vec <- c(rd.2.vec, rd.2)
#     if(OCC==1) break
#   }
# }
# h <- decal[which.min(Occupied_cells)]
# Occupied_cells <- min(Occupied_cells)
if(!is.null(nbe.rep.rast.AOO)) {
Occupied_cells <- c()
# rd.1.vec <- c()
# rd.2.vec <- c()
for (h in 1:nbe.rep.rast.AOO) {
rd.1 <- runif(1)*Cell_size_AOO*1000
rd.2 <- runif(1)*Cell_size_AOO*1000
ext = extent(floor(Corners[1,1])-rd.1-2*Cell_size_AOO*1000, floor(Corners[1,2])+rd.1+2*Cell_size_AOO*1000,
floor(Corners[2,1])-rd.2-2*Cell_size_AOO*1000, floor(Corners[2,2])+rd.2+2*Cell_size_AOO*1000)
r = raster(ext, resolution=Cell_size_AOO*1000, crs=crs(poly_borders))
r
r2_AOO <- rasterize(coordEAC, r)
OCC <- length(which(!is.na(values(r2_AOO))))
Occupied_cells <- c(Occupied_cells, OCC)
# rd.1.vec <- c(rd.1.vec, rd.1)
# rd.2.vec <- c(rd.2.vec, rd.2)
if(OCC==1) break
}
}
h <- decal[which.min(Occupied_cells)]
Occupied_cells <- min(Occupied_cells)
AOO <- Occupied_cells*Cell_size_AOO*Cell_size_AOO  ### AOO
if(EOO<AOO) EOO <- AOO ### If EOO is < AOO, EOO is put equal to AOO
Results["EOO",1] <- as.numeric(EOO)
Results["AOO",1] <- AOO
if(SubPop) Results["Nbe_subPop",1] <- NbeSubPop
Results["Nbe_unique_occ.",1] <- nrow(unique(XY))
if(!is.null(protec.areas)) Results["Nbe_loc",1] <- LocNatParks + LocOutNatParks
if(is.null(protec.areas)) Results["Nbe_loc",1] <- Locations
if(!is.null(protec.areas)) {Results["Nbe_loc_PA",1] <- LocNatParks}
if(!is.null(protec.areas)) Results["Ratio_occ_within_PA",1] <- round(length(which(!is.na(Links_NatParks[,1])))/nrow(Links_NatParks)*100,1)
Nbe_Loc <- as.numeric(Results["Nbe_loc",1])
##################
### Criteria B assessment
if(EOO<20000){
Rank_EOO <- 3
if(EOO<5000){
Rank_EOO <- 2
if(EOO<100){
Rank_EOO <- 1
}}}else(Rank_EOO <- 4)
if(AOO<2000){
Rank_AOO <- 3
if(AOO<500){
Rank_AOO <- 2
if(AOO>10){
Rank_AOO <-1
}}}else{Rank_AOO <- 4}
if(Nbe_Loc<=10){
Rank_Loc <-3
if(Nbe_Loc <=5){
Rank_Loc <-2
if(Nbe_Loc==1){
Rank_Loc <- 1
}}}else{Rank_Loc <- 4}
Rank_B1a <- max(Rank_EOO, Rank_Loc)
Rank_B2a <- max(Rank_AOO, Rank_Loc)
Rank_CriteriaB <- min(Rank_B1a, Rank_B2a)
if(Rank_CriteriaB==1) Cat <- "CR"
if(Rank_CriteriaB==2) Cat <- "EN"
if(Rank_CriteriaB==3 && Nbe_Loc>0 && Nbe_Loc<11) Cat <- "VU"
# if(Rank_CriteriaB==3 && Nbe_Loc==6) Cat <- "VU"
if(Rank_CriteriaB>3 && Nbe_Loc>=0) Cat <- "LC" ###
# if(Rank_CriteriaB>3 && Nbe_Loc>13) Cat <- "LC"
if(Rank_B1a>Rank_B2a) Cat_Code <- paste(Cat,"B2a")
if(Rank_B1a<Rank_B2a) Cat_Code <- paste(Cat,"B1a")
if(Rank_B1a==Rank_B2a) Cat_Code <- paste(Cat,"B1a+B2a")
if(!is.null(protec.areas)) {
if(as.numeric(Results["Ratio_occ_within_PA",1])==100){
Results["Category_CriteriaB",1] <- "NT or LC"
Results["Category_code",1] <- Cat_Code
}else{
Results["Category_CriteriaB",1] <- Cat
Results["Category_code",1] <- Cat_Code
}
}else{
Results["Category_CriteriaB",1] <- Cat
Results["Category_code",1] <- Cat_Code
}
if(Rank_B2a==1) Results["Category_AOO",1] <- "CR"
if(Rank_B2a==2) Results["Category_AOO",1] <- "EN"
if(Rank_B2a==3) Results["Category_AOO",1] <- "VU"
if(Rank_B2a>3) Results["Category_AOO",1] <- "NT or LC"
if(Rank_B1a==1) Results["Category_EOO",1] <- "CR"
if(Rank_B1a==2) Results["Category_EOO",1] <- "EN"
if(Rank_B1a==3) Results["Category_EOO",1] <- "VU"
if(Rank_B1a>3) Results["Category_EOO",1] <- "NT or LC"
}else{
p1 <- NULL
AOO <- nrow(unique(floor((unique(coordEAC))/(Cell_size_AOO*1000))))*Cell_size_AOO*Cell_size_AOO  ### AOO
Results["AOO",1] <- AOO
if(SubPop) Results["Nbe_subPop",1] <- NbeSubPop
Results["Nbe_unique_occ.",1] <- nrow(unique(XY))
if(!is.null(protec.areas)) Results["Ratio_occ_within_PA",1] <- round(length(which(!is.na(Links_NatParks[,1])))/nrow(Links_NatParks)*100,2)
if(is.null(protec.areas)) Results["Nbe_loc",1] <- Locations
if(!is.null(protec.areas)) Results["Nbe_loc",1] <- LocNatParks + LocOutNatParks
if(!is.null(protec.areas)) Results["Nbe_loc_PA",1] <- LocNatParks
if(!is.null(protec.areas)){
if(as.numeric(Results["Ratio_occ_within_PA",1])==100){ ### If all occurences are found within protected areas, the species is considered as not threatened
Results["Category_CriteriaB",1] <- "LC"
}else{
if(Results["Nbe_loc",1]==1 & Results["AOO",1]<10){
Results["Category_CriteriaB",1] <- "CR"
Results["Category_AOO",1] <- "CR"
}
if(Results["Nbe_loc",1]>1 & Results["AOO",1]<10) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}
}
}else{
if(Results["Nbe_loc",1]==1 & Results["AOO",1]<10){
Results["Category_CriteriaB",1] <- "CR"
Results["Category_AOO",1] <- "CR"
}
if(Results["Nbe_loc",1]>1 & Results["AOO",1]<10) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}
}
if(is.na(Results["Category_AOO",1])) {
if(Results["AOO",1] < 500) {
Results["Category_CriteriaB",1] <- "EN"
Results["Category_AOO",1] <- "EN"
}else{
if(Results["AOO",1] < 2000) {
Results["Category_CriteriaB",1] <- "VU"
Results["Category_AOO",1] <- "VU"
}else{
Results["Category_CriteriaB",1] <- "LC"
Results["Category_AOO",1] <- "LC"
}
}
}
Results["Category_code",1] <- paste(Results["Category_CriteriaB",1],"B2a")
if(showWarnings) warning(paste("EOO statistic is not computed for", NamesSp,"because there is less than 3 records"))
} ## End less than 3 records
poly_borders
Corners
Corners <- rbind(c(min(XY[,1]), max(XY[,1])), c(min(XY[,2]), max(XY[,2])))
Corners
.AOO.estimation <- function(coordEAC, Cell_size_AOO=2, nbe.rep.rast.AOO=NULL) {
Corners <- rbind(c(min(coordEAC[,1]), max(coordEAC[,1])), c(min(coordEAC[,2]), max(coordEAC[,2])))
## if nbe.rep.rast.AOO is not provided, translations of 1/4 of resolution for varying the position of the raster
if(is.null(nbe.rep.rast.AOO)) {
Occupied_cells <- c()
decal <- c(0,1,2,3)
for (h in decal) {
ext = extent(floor(Corners[1,1])-h*(Cell_size_AOO*1000/4)-2*Cell_size_AOO*1000, floor(Corners[1,2])+h*(Cell_size_AOO*1000/4)+2*Cell_size_AOO*1000,
floor(Corners[2,1])-h*(Cell_size_AOO*1000/4)-2*Cell_size_AOO*1000, floor(Corners[2,2])+h*(Cell_size_AOO*1000/4)+2*Cell_size_AOO*1000)
r = raster(ext, resolution=Cell_size_AOO*1000,crs=crs(poly_borders))
r2_AOO <- rasterize(coordEAC, r)
OCC <- length(which(!is.na(values(r2_AOO))))
Occupied_cells <- c(Occupied_cells, OCC)
### If only one occupied cell, stop the production of raster
if(OCC==1) break
}
h <- decal[which.min(Occupied_cells)]
Occupied_cells <- min(Occupied_cells)
}
## if nbe.rep.rast.AOO is provided, random starting position of the raster
if(!is.null(nbe.rep.rast.AOO)) {
Occupied_cells <- c()
# rd.1.vec <- c()
# rd.2.vec <- c()
for (h in 1:nbe.rep.rast.AOO) {
rd.1 <- runif(1)*Cell_size_AOO*1000
rd.2 <- runif(1)*Cell_size_AOO*1000
ext = extent(floor(Corners[1,1])-rd.1-2*Cell_size_AOO*1000, floor(Corners[1,2])+rd.1+2*Cell_size_AOO*1000,
floor(Corners[2,1])-rd.2-2*Cell_size_AOO*1000, floor(Corners[2,2])+rd.2+2*Cell_size_AOO*1000)
r = raster(ext, resolution=Cell_size_AOO*1000, crs=crs(poly_borders))
r
r2_AOO <- rasterize(coordEAC, r)
OCC <- length(which(!is.na(values(r2_AOO))))
Occupied_cells <- c(Occupied_cells, OCC)
# rd.1.vec <- c(rd.1.vec, rd.1)
# rd.2.vec <- c(rd.2.vec, rd.2)
if(OCC==1) break
}
}
h <- decal[which.min(Occupied_cells)]
Occupied_cells <- min(Occupied_cells)
AOO <- Occupied_cells*Cell_size_AOO*Cell_size_AOO  ### AOO
return(AOO)
}
.AOO.estimation(coordEAC, Cell_size_AOO = Cell_size_AOO, nbe.rep.rast.AOO = nbe.rep.rast.AOO)
AOO <- .AOO.estimation(coordEAC, Cell_size_AOO = Cell_size_AOO, nbe.rep.rast.AOO = nbe.rep.rast.AOO)
AOO
pairwise_dist
max(pairwise_dist)
protec.areas
r2_pol <- rasterToPolygons(r2, fun=NULL, n=4, na.rm=TRUE, digits=6, dissolve=FALSE)
plot(r2_pol, col=rgb(red=1, green=0, blue=0, alpha=0.2),
xlim=c(range(XY[,1])[1]-1, range(XY[,1])[2]+1), ylim=c(range(XY[,2])[1]-1, range(XY[,2])[2]+1))
if(SubPop) plot(SubPopPoly, add=T, border="black", lwd=2, lty=1)
!is.null(p1)
if(!is.null(p1)) plot(p1, add=T, col=rgb(red=0.2, green=0.2, blue=0.2, alpha=0.1))
load_all("ConR")
data(dataset.ex)
MyData <- dataset.ex
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = F)
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = F, nbe.rep.rast.AOO = 20)
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = T, nbe.rep.rast.AOO = 20, exclude.area = T, draw.poly.EOO = F)
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = T, nbe.rep.rast.AOO = 20, exclude.area = T, draw.poly.EOO = F)
load_all("ConR")
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = T, nbe.rep.rast.AOO = 20, exclude.area = T, draw.poly.EOO = F)
IUCN.eval(MyData, Cell_size_AOO = 20, DrawMap = T, nbe.rep.rast.AOO = 20, exclude.area = T, draw.poly.EOO = F, file_name = "test", map_pdf = T)
library(devtools)
setwd("C:/MonDossierR/")
load_all("ConR")
data(dataset.ex)
MyData <- dataset.ex
IUCN.eval(MyData)
DATA=MyData
#
Cell_size_AOO=2
Cell_size_locations=10
Resol_sub_pop=5
method_locations=c("fixed_grid")
Rel_cell_size=0.05
DrawMap=T
add.legend=TRUE
file_name=NULL
export_shp=FALSE
write_shp=FALSE
protec.areas=NULL
map_pdf=FALSE
exclude.area=FALSE
method_protected_area="no_more_than_one"
ID_shape_PA="WDPA_PID"
buff_width=0.1
country_map=land
SubPop=T
alpha=1
method.range="convex.hull"
verbose=TRUE
showWarnings=TRUE
if(class(DATA)=="spgeoIN") {
DATA_2 <- cbind(DATA$species_coordinates, DATA$identifier)
DATA <- DATA_2[,c(2,1,3)]
}
colnames(DATA)[1:3] <- c("ddlat","ddlon","tax")
if(any(is.na(DATA[,1:2]))) {
length(which(rowMeans(is.na(DATA[,1:2]))>0))
unique(DATA[which(rowMeans(is.na(DATA[,1:2]))>0),3])
print(paste("Skipping",length(which(rowMeans(is.na(DATA[,1:2]))>0)) ,"occurrences because of missing coordinates for",
paste(as.character(unique(DATA[which(rowMeans(is.na(DATA[,1:2]))>0),3])), collapse=" AND ") ))
DATA <- DATA[which(!is.na(DATA[,1])),]
DATA <- DATA[which(!is.na(DATA[,2])),]
}
if(is.factor(DATA[,"tax"])) DATA[,"tax"] <- as.character(DATA[,"tax"])
if(!is.numeric(DATA[,1]) || !is.numeric(DATA[,2])) stop("coordinates in DATA should be numeric")
if(any(DATA[,1]>180) || any(DATA[,1]< -180)|| any(DATA[,2]< -180) || any(DATA[,2]>180)) stop("coordinates are out of expected range")
if(!is.null(country_map)) if(!class(country_map)=="SpatialPolygonsDataFrame") stop("Country_map should be a spatialpolygondataframe")
if(!is.null(protec.areas)) {
if(!class(protec.areas)=="SpatialPolygonsDataFrame") stop("protec.areas should be a spatialpolygondataframe")
if(!any(colnames(protec.areas@data) %in% ID_shape_PA)) stop("Check argument ID_shape_PA because selected ID field in the protected area shapefile does not exist")
}
if(is.null(country_map)) {
data('land', package='ConR', envir=environment())
land <- get("land", envir=environment())
country_map <- land
}
if(!is.null(protec.areas)) {
if(!identicalCRS(protec.areas, land)) crs(protec.areas) <-crs(land)
}
#if(is.null(country_map)) stop("country_map is mandatory")
if(length(grep("[?]", DATA[,3]))>0) DATA[,3] <- gsub("[?]", "_", DATA[,3])
if(length(grep("[/]", DATA[,3]))>0) DATA[,3] <- gsub("[/]", "_", DATA[,3])
#####
list_data <- split(DATA, f = DATA$tax)
#   ptm <- proc.time()
if(map_pdf){
if(!is.null(file_name)) {
NAME_FILE <- file_name
}else{
NAME_FILE <- "IUCN_"
}
FILE_NAME <- ifelse(!is.null(file_name), file_name, "IUCN_")
dir.create(file.path(paste(getwd(),paste("/",FILE_NAME,"_results_map", sep=""), sep="")), showWarnings = FALSE)
pdf(paste(paste(getwd(),paste("/",FILE_NAME,"_results_map", sep=""), sep=""),"/","results.pdf", sep=""), width=25, height=25)
}
DATA=MyData
#
Cell_size_AOO=2
Cell_size_locations=10
Resol_sub_pop=5
method_locations=c("fixed_grid")
Rel_cell_size=0.05
DrawMap=T
add.legend=TRUE
file_name=NULL
export_shp=FALSE
write_shp=FALSE
protec.areas=NULL
map_pdf=FALSE
exclude.area=FALSE
method_protected_area="no_more_than_one"
ID_shape_PA="WDPA_PID"
buff_width=0.1
country_map=NULL
SubPop=T
alpha=1
method.range="convex.hull"
verbose=TRUE
showWarnings=TRUE
DATA <- list_data[[1]]
MinMax=c(min(DATA[,2]), max(DATA[,2]), min(DATA[,1]), max(DATA[,1]))
poly_borders=NULL
verbose=TRUE
showWarnings=TRUE
NamesSp="Aglyptodactylus madagascariensis"
if(class(DATA)=="spgeoIN") {
DATA_2 <- cbind(DATA$species_coordinates, DATA$identifier)
DATA <- DATA_2[,c(2,1,3)]
}
colnames(DATA)[1:3] <- c("ddlat","ddlon","tax")
if(any(is.na(DATA[,1:2]))) {
length(which(rowMeans(is.na(DATA[,1:2]))>0))
unique(DATA[which(rowMeans(is.na(DATA[,1:2]))>0),3])
print(paste("Skipping",length(which(rowMeans(is.na(DATA[,1:2]))>0)) ,"occurrences because of missing coordinates for",
paste(as.character(unique(DATA[which(rowMeans(is.na(DATA[,1:2]))>0),3])), collapse=" AND ") ))
DATA <- DATA[which(!is.na(DATA[,1])),]
DATA <- DATA[which(!is.na(DATA[,2])),]
}
if(is.factor(DATA[,"tax"])) DATA[,"tax"] <- as.character(DATA[,"tax"])
if(!is.numeric(DATA[,1]) || !is.numeric(DATA[,2])) stop("coordinates in DATA should be numeric")
if(any(DATA[,1]>180) || any(DATA[,1]< -180)|| any(DATA[,2]< -180) || any(DATA[,2]>180)) stop("coordinates are out of expected range")
if(!is.null(country_map)) if(!class(country_map)=="SpatialPolygonsDataFrame") stop("Country_map should be a spatialpolygondataframe")
if(!is.null(protec.areas)) {
if(!class(protec.areas)=="SpatialPolygonsDataFrame") stop("protec.areas should be a spatialpolygondataframe")
if(!any(colnames(protec.areas@data) %in% ID_shape_PA)) stop("Check argument ID_shape_PA because selected ID field in the protected area shapefile does not exist")
}
if(is.null(country_map)) {
data('land', package='ConR', envir=environment())
land <- get("land", envir=environment())
country_map <- land
}
if(!is.null(protec.areas)) {
if(!identicalCRS(protec.areas, land)) crs(protec.areas) <-crs(land)
}
#if(is.null(country_map)) stop("country_map is mandatory")
if(length(grep("[?]", DATA[,3]))>0) DATA[,3] <- gsub("[?]", "_", DATA[,3])
if(length(grep("[/]", DATA[,3]))>0) DATA[,3] <- gsub("[/]", "_", DATA[,3])
#####
list_data <- split(DATA, f = DATA$tax)
#   ptm <- proc.time()
if(map_pdf){
if(!is.null(file_name)) {
NAME_FILE <- file_name
}else{
NAME_FILE <- "IUCN_"
}
FILE_NAME <- ifelse(!is.null(file_name), file_name, "IUCN_")
dir.create(file.path(paste(getwd(),paste("/",FILE_NAME,"_results_map", sep=""), sep="")), showWarnings = FALSE)
pdf(paste(paste(getwd(),paste("/",FILE_NAME,"_results_map", sep=""), sep=""),"/","results.pdf", sep=""), width=25, height=25)
}
country_map
### cropping poly_borders according to range of occurrences shapefile for producing lighter maps
if(DrawMap) {
full_poly_borders <- poly_borders
poly_borders <- crop(poly_borders, extent(MinMax)+30)
}
IUCN.eval(MyData)
library(devtools)
setwd("C:/MonDossierR/")
load_all("ConR")
data(dataset.ex)
MyData <- dataset.ex
IUCN.eval(MyData)
